/// Wraps up logic around converting project files into lists of arguments for FSI
module FsAutoComplete.ScriptContext

module List =
    let satisfyAll tests list =
        let combinedTest = tests |> List.reduce (fun f j -> fun x -> f x && j x)
        list |> List.filter combinedTest


let inline isReference (option: string) = option.StartsWith "-r:" || option.StartsWith ("--reference:")

let inline isRefAssembly (reference: string) = reference.Contains("/ref/")

let isValidFSIReference (reference: string) = not <| isRefAssembly reference

let isValidFSIOption =
    let badOptions =
        Set.ofList
            [ "--nocopyfsharpcore"
              "--noframework"
              "--highentropyva-" ]
    badOptions.Contains >> not

let isNotReference = isReference >> not

let isNotOutput (option: string) = not <| option.StartsWith "-o:"

let isNotTarget (option: string) = not <| option.StartsWith "--target:"

let makeForProject (projectInfo: ProjectCrackerCache) =
    // TODO: TFM differences?
    let dllReferences =
        projectInfo.References
        |> List.filter isValidFSIReference
        |> List.map (sprintf "--reference:%s")

    let otherOptions =
        projectInfo.Options.OtherOptions
        |> List.ofArray
        |> List.satisfyAll [ isValidFSIOption; isNotReference; isNotOutput; isNotTarget]

    // TODO: check referenced projects and figure out
    // a) what their output dll path is
    // b) if it's built or not.
    // if not built, throw an error?
    let referencedProjects = []

    let allFSIOptions =
        dllReferences @ otherOptions @ referencedProjects

    [], allFSIOptions

let makeForFileInProject (sourceFilePath: string) (projectInfo: ProjectCrackerCache) =
    // gather script/options from the project-level
    let script, options = makeForProject projectInfo

    // append to this a 'load' of each file in the project that comes before the given file
    let files = projectInfo.Items |> List.map (function | Dotnet.ProjInfo.Workspace.ProjectViewerItem.Compile(path, _config) -> path)
    let filesBefore = files |> List.takeWhile (fun file -> file <> sourceFilePath)

    // Use 'load' instead of 'use' because 'use' is intended for fsx files, and we're loading fs source files here.
    // By adding these as fsi parameters instead of #load directives inside a script, we should ensure that they are part of the initially-compiled
    // dynamic assembly, rather than any that are generated as part of parsing the 'script' generated by user interactions.
    let fsiLoadOperations =
        filesBefore
        |> List.map (sprintf "--load:%s")

    script, options @ fsiLoadOperations
